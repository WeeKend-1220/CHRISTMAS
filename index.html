<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Christmas Tree - Final No Blue</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ„</text></svg>">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Times New Roman', serif; }
        #ui-container {
            position: absolute; top: 30px; width: 100%; text-align: center; color: #d4af37;
            pointer-events: none; z-index: 10; text-shadow: 0 0 15px rgba(212, 175, 55, 0.8);
        }
        h1 { margin: 0; font-size: 3.5rem; letter-spacing: 8px; font-weight: bold; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-family: sans-serif; pointer-events: none; transition: opacity 0.8s;
            font-size: 1.2rem; letter-spacing: 2px;
        }
        .bg-gradient {
            position: absolute; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a0b0b 0%, #000000 100%); z-index: -1;
        }
    </style>
</head>
<body>

    <audio id="bgm" loop>
        <source src="https://commondatastorage.googleapis.com/codeskulptor-demos/riceracer_assets/music/win.ogg" type="audio/ogg"> 
    </audio>

    <div class="bg-gradient"></div>

    <div id="ui-container">
        <h1>MERRY CHRISTMAS</h1>
        <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px; font-style: italic;">
            CLICK TO INTERACT | DRAG TO ROTATE
        </p>
    </div>

    <div id="loading">Growing More Leaves & Painting Gifts...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        const dummy = new THREE.Object3D();

        // --- å‚æ•°é…ç½® ---
        const LEAF_COUNT = 12000;      // èŒ‚å¯†çš„ç»¿è‰²ç²’å­
        const ORNAMENT_COUNT = 800;    // å®ä½“è£…é¥°å“
        const TEXT_PARTICLE_COUNT = 6000; // é‡‘è‰²æ–‡å­—ç²’å­
        
        const SPREAD_RADIUS = 45;   
        const TREE_HEIGHT = 24;
        const TREE_RADIUS = 10;
        
        // --- åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a110a, 0.012);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 65);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping; 
        renderer.toneMappingExposure = 1.3;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = false;
        controls.maxDistance = 100;
        controls.minDistance = 15;

        // --- ç¯å…‰ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const mainLight = new THREE.PointLight(0xffd700, 180, 150);
        mainLight.position.set(15, 30, 15);
        mainLight.castShadow = true;
        scene.add(mainLight);
        const sideLight = new THREE.PointLight(0xff6a00, 100, 100);
        sideLight.position.set(-20, 15, 5);
        scene.add(sideLight);
        const bottomGreenLight = new THREE.PointLight(0x00ff00, 60, 80);
        bottomGreenLight.position.set(0, -15, 0);
        scene.add(bottomGreenLight);

        // --- è¾…åŠ©å‡½æ•°ï¼šå‘å…‰çº¹ç† ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 200, 50, 1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        // =================================================================
        // ç³»ç»Ÿ 1: ç»¿è‰²å¶å­ç²’å­ (èŒ‚å¯†èƒŒæ™¯)
        // =================================================================
        const leafGeometry = new THREE.BufferGeometry();
        const leafPositions = new Float32Array(LEAF_COUNT * 3);
        const leafColors = new Float32Array(LEAF_COUNT * 3);
        const leafData = [];
        const colorGreen1 = new THREE.Color(0x006400);
        const colorGreen2 = new THREE.Color(0x228B22);
        const tempColor = new THREE.Color();

        for (let i = 0; i < LEAF_COUNT; i++) {
            leafPositions[i * 3] = 0; leafPositions[i * 3 + 1] = 0; leafPositions[i * 3 + 2] = 0;
            tempColor.lerpColors(colorGreen1, colorGreen2, Math.random());
            leafColors[i * 3] = tempColor.r; leafColors[i * 3 + 1] = tempColor.g; leafColors[i * 3 + 2] = tempColor.b;
            const treePos = getTreePosition(0.92);
            leafData.push({
                current: treePos.clone(), target: treePos.clone(), treePos: treePos, 
                explodePos: getExplodePosition(1.3), // ç‚¸å¾—è¿œ
                velocity: new THREE.Vector3()
            });
        }
        leafGeometry.setAttribute('position', new THREE.BufferAttribute(leafPositions, 3));
        leafGeometry.setAttribute('color', new THREE.BufferAttribute(leafColors, 3));
        const leafMaterial = new THREE.PointsMaterial({ size: 0.25, vertexColors: true, transparent: true, opacity: 0.5, sizeAttenuation: true });
        const leafPointsMesh = new THREE.Points(leafGeometry, leafMaterial);

        // =================================================================
        // ç³»ç»Ÿ 2: PBR å®ä½“è£…é¥°å“ (ç‚¸å¼€æ—¶å¯è§)
        // =================================================================
        const metalMaterialSettings = { metalness: 0.6, roughness: 0.2, envMapIntensity: 1.5 };
        const materialSphere = new THREE.MeshStandardMaterial(metalMaterialSettings);
        const materialBox = new THREE.MeshStandardMaterial({ ...metalMaterialSettings, roughness: 0.25 });
        const geometrySphere = new THREE.SphereGeometry(0.3, 16, 16);
        const geometryBox = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        const countSphere = Math.floor(ORNAMENT_COUNT / 2);
        const countBox = ORNAMENT_COUNT - countSphere;
        const iMeshSphere = new THREE.InstancedMesh(geometrySphere, materialSphere, countSphere);
        const iMeshBox = new THREE.InstancedMesh(geometryBox, materialBox, countBox);
        iMeshSphere.castShadow = true; iMeshSphere.receiveShadow = true;
        iMeshBox.castShadow = true; iMeshBox.receiveShadow = true;

        const _color = new THREE.Color();
        const ornamentData = []; 
        
        // çƒä½“é¢œè‰² (é‡‘è‰²å’Œçº¢è‰²ï¼Œé«˜äº®)
        for (let i = 0; i < countSphere; i++) {
            Math.random() > 0.4 ? _color.setHex(0xFFD700).multiplyScalar(1.3) : _color.setHex(0xD40000).multiplyScalar(1.3);
            iMeshSphere.setColorAt(i, _color);
        }

        // ã€ä¿®æ”¹ç‚¹ã€‘ç«‹æ–¹ä½“é¢œè‰²é‡æ–°åˆ†é…ï¼šå»æ‰è“è‰²ï¼Œåªä¿ç•™é«˜äº®é‡‘è‰²å’Œé²œè‰³ç¿ ç»¿
        for (let i = 0; i < countBox; i++) {
            if (Math.random() > 0.5) {
                _color.setHex(0xFFD700).multiplyScalar(1.3); // é«˜äº®é‡‘è‰²
            } else {
                _color.setHex(0x00D500).multiplyScalar(1.3); // é²œè‰³ç¿ ç»¿
            }
            iMeshBox.setColorAt(i, _color);
        }
        iMeshSphere.instanceColor.needsUpdate = true; iMeshBox.instanceColor.needsUpdate = true;

        for (let i = 0; i < ORNAMENT_COUNT; i++) {
            const treePos = getTreePosition(1.05);
            ornamentData.push({
                current: treePos.clone(), target: treePos.clone(), treePos: treePos, 
                explodePos: getExplodePosition(0.6), // ç‚¸å¾—è¿‘ï¼Œå¯è§
                velocity: new THREE.Vector3()
            });
        }

        // =================================================================
        // ç³»ç»Ÿ 3: é‡‘è‰²å‘å…‰ç²’å­ (æ–‡å­—ä¸“ç”¨)
        // =================================================================
        const glowGeometry = new THREE.BufferGeometry();
        const glowPositions = new Float32Array(TEXT_PARTICLE_COUNT * 3);
        const glowData = [];
        
        for (let i = 0; i < TEXT_PARTICLE_COUNT; i++) {
            glowPositions[i*3] = 0; glowPositions[i*3+1] = 0; glowPositions[i*3+2] = 0;
            const treePos = getTreePosition(1.1); 
            glowData.push({
                current: treePos.clone(), target: treePos.clone(), treePos: treePos, 
                explodePos: getExplodePosition(1.2), 
                textPos: new THREE.Vector3(0,0,0),
                velocity: new THREE.Vector3()
            });
        }
        glowGeometry.setAttribute('position', new THREE.BufferAttribute(glowPositions, 3));
        
        const glowMaterial = new THREE.PointsMaterial({
            color: 0xffaa00,
            size: 0.5,
            map: createGlowTexture(),
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });
        const glowPointsMesh = new THREE.Points(glowGeometry, glowMaterial);

        // --- æ ‘é¡¶ ---
        const topperMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffd700, emissiveIntensity: 0.8, metalness: 0.8, roughness: 0.1 });
        const topperMesh = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), topperMaterial);
        topperMesh.position.y = TREE_HEIGHT / 2 + 1.0;
        topperMesh.add(new THREE.PointLight(0xffff00, 100, 30));

        // ç»„è£…
        const treeGroup = new THREE.Group();
        treeGroup.add(leafPointsMesh); 
        treeGroup.add(iMeshSphere); 
        treeGroup.add(iMeshBox); 
        treeGroup.add(glowPointsMesh);
        treeGroup.add(topperMesh);
        scene.add(treeGroup);

        let currentState = 0; 

        // --- ä½ç½®å‡½æ•° ---
        function getTreePosition(radiusModifier = 1.0) {
            const h = Math.random() * TREE_HEIGHT;
            const r = (1 - h / TREE_HEIGHT) * TREE_RADIUS * Math.sqrt(Math.random()) * radiusModifier; 
            const theta = Math.random() * Math.PI * 2;
            return new THREE.Vector3(r * Math.cos(theta), h - TREE_HEIGHT / 2, r * Math.sin(theta));
        }
        function getExplodePosition(scale = 1.0) {
            return new THREE.Vector3().randomDirection().multiplyScalar(SPREAD_RADIUS * (0.8 + Math.random() * 0.6) * scale);
        }

        // --- æ ¸å¿ƒé€»è¾‘æ›´æ–° ---
        function updateParticles() {
            // 1. å¶å­
            const leafPosAttr = leafGeometry.attributes.position.array;
            for (let i = 0; i < LEAF_COUNT; i++) {
                const p = leafData[i];
                p.velocity.add(p.target.clone().sub(p.current).multiplyScalar(0.04));
                p.velocity.multiplyScalar(0.85);
                p.current.add(p.velocity);
                leafPosAttr[i * 3] = p.current.x; leafPosAttr[i * 3 + 1] = p.current.y; leafPosAttr[i * 3 + 2] = p.current.z;
            }
            leafGeometry.attributes.position.needsUpdate = true;

            // 2. è£…é¥°å“ (å®ä½“)
            let idxSphere = 0, idxBox = 0;
            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                const p = ornamentData[i];
                p.velocity.add(p.target.clone().sub(p.current).multiplyScalar(0.06));
                p.velocity.multiplyScalar(0.88);
                p.current.add(p.velocity);
                dummy.position.copy(p.current);
                // æŒç»­è‡ªè½¬
                dummy.rotation.x += 0.02; dummy.rotation.y += 0.02;
                dummy.updateMatrix();
                if (i < countSphere) iMeshSphere.setMatrixAt(idxSphere++, dummy.matrix);
                else iMeshBox.setMatrixAt(idxBox++, dummy.matrix);
            }
            iMeshSphere.instanceMatrix.needsUpdate = true; iMeshBox.instanceMatrix.needsUpdate = true;

            // 3. é‡‘è‰²å‘å…‰ç²’å­
            const glowPosAttr = glowGeometry.attributes.position.array;
            for (let i = 0; i < TEXT_PARTICLE_COUNT; i++) {
                const p = glowData[i];
                const force = p.target.clone().sub(p.current).multiplyScalar(0.08);
                p.velocity.add(force);
                p.velocity.multiplyScalar(0.82);
                p.current.add(p.velocity);
                glowPosAttr[i * 3] = p.current.x; glowPosAttr[i * 3 + 1] = p.current.y; glowPosAttr[i * 3 + 2] = p.current.z;
            }
            glowGeometry.attributes.position.needsUpdate = true;
        }

        // åˆå§‹åŒ–
        leafData.forEach(p => p.current.copy(p.treePos));
        ornamentData.forEach(p => p.current.copy(p.treePos));
        glowData.forEach(p => p.current.copy(p.treePos));

        // --- å­—ä½“åŠ è½½ (è¡¨é¢é‡‡æ ·) ---
        const loader = new FontLoader();
        loader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
            const textGeo = new TextGeometry('MERRY\nCHRISTMAS', { font: font, size: 3.5, height: 0.01, curveSegments: 6, bevelEnabled: false });
            textGeo.center();
            const posAttribute = textGeo.attributes.position;
            const triangleCount = posAttribute.count / 3;
            const areas = [];
            let totalArea = 0;
            const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3(), va = new THREE.Vector3(), vb = new THREE.Vector3();
            for (let i = 0; i < triangleCount; i++) {
                a.fromBufferAttribute(posAttribute, i * 3 + 0); b.fromBufferAttribute(posAttribute, i * 3 + 1); c.fromBufferAttribute(posAttribute, i * 3 + 2);
                va.subVectors(b, a); vb.subVectors(c, a);
                const area = va.cross(vb).length() * 0.5;
                areas.push(area); totalArea += area;
            }
            for (let i = 0; i < TEXT_PARTICLE_COUNT; i++) {
                let r = Math.random() * totalArea; let triangleIndex = 0;
                for (let j = 0; j < areas.length; j++) { r -= areas[j]; if (r <= 0) { triangleIndex = j; break; } }
                a.fromBufferAttribute(posAttribute, triangleIndex * 3 + 0); b.fromBufferAttribute(posAttribute, triangleIndex * 3 + 1); c.fromBufferAttribute(posAttribute, triangleIndex * 3 + 2);
                let r1 = Math.random(), r2 = Math.random(); if (r1 + r2 > 1) { r1 = 1 - r1; r2 = 1 - r2; }
                const p = new THREE.Vector3(); p.addScaledVector(a, 1 - r1 - r2); p.addScaledVector(b, r1); p.addScaledVector(c, r2);
                p.z = (Math.random() - 0.5) * 0.05; 
                glowData[i].textPos = p;
            }
            document.getElementById('loading').style.opacity = 0;
        });

        // --- äº¤äº’ ---
        function nextState() {
            currentState = (currentState + 1) % 3;
            const bgm = document.getElementById('bgm');
            if (bgm && bgm.paused) { bgm.play().catch(e => {}); }

            if (currentState === 0) { // Tree State
                leafData.forEach(p => { p.target.copy(p.treePos); });
                ornamentData.forEach(p => { p.target.copy(p.treePos); });
                glowData.forEach(p => { p.target.copy(p.treePos); });
                topperMesh.visible = true;
            } else if (currentState === 1) { // Explode State
                leafData.forEach(p => { p.target.copy(p.explodePos); });
                // è£…é¥°å“åœ¨ç‚¸å¼€çŠ¶æ€ä¸‹ï¼Œé£å‘è¾ƒè¿‘çš„ä½ç½®
                ornamentData.forEach(p => { p.target.copy(p.explodePos); });
                glowData.forEach(p => { p.target.copy(p.explodePos); });
                topperMesh.visible = false;
            } else if (currentState === 2) { // Text State
                leafData.forEach(p => { p.target.copy(p.explodePos); });
                // åœ¨æ–‡å­—çŠ¶æ€ä¸‹ï¼Œè£…é¥°å“ä¾ç„¶ä¿æŒåœ¨è¾ƒè¿‘çš„çˆ†ç‚¸ä½ç½®æ‚¬æµ®
                ornamentData.forEach(p => { p.target.copy(p.explodePos); });
                glowData.forEach(p => { p.target.copy(p.textPos); }); 
                topperMesh.visible = false;
            }
        }

        let isDragging = false;
        let mouseDownTime = 0;
        window.addEventListener('mousedown', () => { isDragging = false; mouseDownTime = Date.now(); });
        window.addEventListener('mousemove', () => { isDragging = true; });
        window.addEventListener('mouseup', () => {
            if (Date.now() - mouseDownTime < 250 && !isDragging) nextState();
        });
        window.addEventListener('touchstart', () => { mouseDownTime = Date.now(); isDragging = false; });
        window.addEventListener('touchmove', () => { isDragging = true; });
        window.addEventListener('touchend', () => {
            if (Date.now() - mouseDownTime < 250 && !isDragging) nextState();
        });

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (currentState === 0) {
                treeGroup.rotation.y += 0.003; 
            } else if (currentState === 2) {
                let targetRot = 0;
                const currentRot = treeGroup.rotation.y % (Math.PI * 2);
                if (currentRot > Math.PI) targetRot = Math.PI * 2;
                else if (currentRot < -Math.PI) targetRot = -Math.PI * 2;
                treeGroup.rotation.y = THREE.MathUtils.lerp(treeGroup.rotation.y, targetRot, 0.08);
                treeGroup.rotation.x = THREE.MathUtils.lerp(treeGroup.rotation.x, 0, 0.08);
                treeGroup.rotation.z = THREE.MathUtils.lerp(treeGroup.rotation.z, 0, 0.08);
            } else {
                treeGroup.rotation.y += 0.001;
            }

            updateParticles();
            
            // é—ªçƒç‰¹æ•ˆ
            if (currentState === 0) {
                const scale = 1.0 + Math.sin(time * 3) * 0.3;
                glowMaterial.size = 0.5 * scale;
            } else if (currentState === 2) {
                glowMaterial.size = 0.6;
            }

            if (topperMesh.visible) {
                topperMesh.position.y = (TREE_HEIGHT / 2 + 1.2) + Math.sin(time * 2.5) * 0.25;
                topperMesh.rotation.y += 0.03;
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>